# -*- coding: utf-8 -*-
"""Gold_EDA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VLWscFb7rYOHY2J4iGqyxXn_FXNdiTml
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import io
import seaborn as sns

df = pd.read_csv('drive/MyDrive/gold.csv')

df.head()

# 1. Basic Data Inspection
print("="*50)
print("DATA SHAPE:")
print(f"Rows: {df.shape[0]}, Columns: {df.shape[1]}")
print("\nCOLUMN NAMES:")
print(df.columns.tolist())
print("\nDATA TYPES:")
print(df.dtypes)

# 2. Sample Data Inspection
print("\n" + "="*50)
print("FIRST 5 RECORDS:")
print(df.head())
print("\nRANDOM 5 RECORDS:")
print(df.sample(5))
print("\nBASIC STATISTICS:")
print(df.describe())

# 3. Data Quality Checks
print("\n" + "="*50)
print("MISSING VALUES:")
print(df.isnull().sum())
print("\nDUPLICATED ROWS:", df.duplicated().sum())

# 4. Data Visualization
plt.figure(figsize=(15, 10))

# Price Trends
plt.subplot(2, 2, 1)
plt.plot(pd.to_datetime(df['Date']), df['Close'], color='royalblue')
plt.title('Gold Closing Price Trend (2000-2006)')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.grid(alpha=0.3)

# Daily Price Distribution
plt.subplot(2, 2, 2)
plt.hist(df['Close'], bins=50, color='darkorange', edgecolor='black')
plt.title('Closing Price Distribution')
plt.xlabel('Price (USD)')
plt.ylabel('Frequency')

# Volatility Analysis
daily_returns = df['Close'].pct_change() * 100
plt.subplot(2, 2, 3)
plt.plot(pd.to_datetime(df['Date']), daily_returns, color='forestgreen', alpha=0.7)
plt.title('Daily Returns (%)')
plt.xlabel('Date')
plt.ylabel('Percentage Change')
plt.grid(alpha=0.3)

# Volume Analysis
plt.subplot(2, 2, 4)
plt.bar(pd.to_datetime(df['Date']), df['Volume'], color='purple', alpha=0.7)
plt.title('Trading Volume Over Time')
plt.xlabel('Date')
plt.ylabel('Volume')

plt.tight_layout()
plt.show()

# 5. Correlation Analysis
corr_matrix = df[['Open','High','Low','Close','Volume']].corr()
print("\n" + "="*50)
print("CORRELATION MATRIX:")
print(corr_matrix)

# 6. Time Period Analysis
df['Year'] = pd.to_datetime(df['Date']).dt.year
annual_avg = df.groupby('Year')['Close'].mean()

plt.figure(figsize=(10, 5))
annual_avg.plot(kind='bar', color='teal')
plt.title('Average Annual Closing Price')
plt.xlabel('Year')
plt.ylabel('Average Price (USD)')
plt.xticks(rotation=0)
plt.grid(axis='y', alpha=0.3)
plt.show()

"""# Data Cleaning"""

# Handle zero-volume days (market holidays)
zero_volume_days = df[df['Volume'] == 0]
print(f"\nZero-volume days found: {len(zero_volume_days)}")
df = df[df['Volume'] > 0]  # Remove zero-volume days

# Outlier detection using IQR
plt.figure(figsize=(15, 8))

# Price Outliers
plt.subplot(2, 2, 1)
sns.boxplot(x=df['Close'], color='skyblue')
plt.title('Closing Price Distribution')
plt.xlabel('Price (USD)')

# Volume Outliers
plt.subplot(2, 2, 2)
sns.boxplot(x=df['Volume'], color='lightgreen')
plt.title('Trading Volume Distribution')
plt.xlabel('Volume')

# IQR Calculation for Volume
Q1 = df['Volume'].quantile(0.25)
Q3 = df['Volume'].quantile(0.75)
IQR = Q3 - Q1
volume_outlier_threshold = Q3 + (1.5 * IQR)
print(f"\nVolume outlier threshold (IQR method): {volume_outlier_threshold:.0f}")

# Identify and visualize price outliers
df['Returns'] = df['Close'].pct_change() * 100
price_outliers = df[np.abs(df['Returns']) > 10]  # Days with >10% price moves

plt.subplot(2, 2, 3)
plt.scatter(df['Date'], df['Close'], alpha=0.6, label='Normal Days')
plt.scatter(price_outliers['Date'], price_outliers['Close'],
            color='red', label='Price Outliers (>10% move)')
plt.title('Price Outliers Detection')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.legend()

# Volume outliers visualization
volume_outliers = df[df['Volume'] > volume_outlier_threshold]

plt.subplot(2, 2, 4)
plt.plot(df['Date'], df['Volume'], alpha=0.6, label='Normal Volume')
plt.scatter(volume_outliers['Date'], volume_outliers['Volume'],
            color='red', label='Volume Outliers')
plt.title('Volume Outliers Detection')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend()

plt.tight_layout()
plt.show()

# Data validation checks
print("\nDATA VALIDATION CHECKS:")
# Check for high>low inconsistencies
high_low_errors = df[df['High'] < df['Low']]
print(f"Rows with High < Low: {len(high_low_errors)}")
df = df[df['High'] >= df['Low']]  # Remove invalid rows

# Check for open/close outside high/low range
range_errors = df[
    (df['Open'] > df['High']) |
    (df['Open'] < df['Low']) |
    (df['Close'] > df['High']) |
    (df['Close'] < df['Low'])
]
print(f"Rows with prices outside daily range: {len(range_errors)}")

# Add volatility-adjusted z-scores
df['Volatility'] = df['Close'].rolling(window=30).std()
df['Price_ZScore'] = (df['Close'] - df['Close'].rolling(window=30).mean()) / df['Volatility']

# Final cleaned dataset
print(f"\nFinal dataset shape: {df.shape}")

"""# Univariate Analysis"""

import seaborn as sns
import scipy.stats as stats

# Set up subplots
fig, axes = plt.subplots(4, 2, figsize=(18, 20))
fig.suptitle('Gold Market Univariate Analysis', fontsize=20, y=0.98)

# 1. Closing Price Analysis
# --------------------------
sns.histplot(df['Close'], kde=True, ax=axes[0,0], color='goldenrod', bins=50)
axes[0,0].axvline(df['Close'].mean(), color='darkred', linestyle='--', label=f'Mean: ${df["Close"].mean():.2f}')
axes[0,0].axvline(df['Close'].median(), color='navy', linestyle='-', label=f'Median: ${df["Close"].median():.2f}')
axes[0,0].set_title('Closing Price Distribution', fontsize=15)
axes[0,0].set_xlabel('Price (USD)')
axes[0,0].legend()

stats.probplot(df['Close'], plot=axes[0,1])
axes[0,1].set_title('Closing Price Q-Q Plot', fontsize=15)

# 2. Daily Returns Analysis
# --------------------------
sns.histplot(df['Returns'].dropna(), kde=True, ax=axes[1,0], color='teal', bins=100)
axes[1,0].axvline(df['Returns'].mean(), color='darkred', linestyle='--', label=f'Mean: {df["Returns"].mean():.2f}%')
axes[1,0].set_title('Daily Returns Distribution', fontsize=15)
axes[1,0].set_xlabel('Daily Return (%)')
axes[1,0].set_xlim([-15, 15])
axes[1,0].legend()

sns.boxplot(x=df['Returns'], ax=axes[1,1], color='lightgreen')
axes[1,1].set_title('Daily Returns Boxplot', fontsize=15)
axes[1,1].set_xlabel('Daily Return (%)')

# 3. Trading Volume Analysis
# --------------------------
sns.histplot(df['Volume'], kde=True, ax=axes[2,0], color='purple', bins=50)
axes[2,0].axvline(df['Volume'].mean(), color='darkred', linestyle='--', label=f'Mean: {df["Volume"].mean():,.0f}')
axes[2,0].axvline(df['Volume'].median(), color='navy', linestyle='-', label=f'Median: {df["Volume"].median():,.0f}')
axes[2,0].set_title('Trading Volume Distribution', fontsize=15)
axes[2,0].set_xlabel('Volume (Contracts)')
axes[2,0].legend()

sns.boxplot(x=df['Volume'], ax=axes[2,1], color='violet')
axes[2,1].set_title('Trading Volume Boxplot', fontsize=15)
axes[2,1].set_xlabel('Volume (Contracts)')

# 4. Volatility Analysis
# --------------------------
sns.histplot(df['Volatility'].dropna(), kde=True, ax=axes[3,0], color='steelblue', bins=50)
axes[3,0].axvline(df['Volatility'].mean(), color='darkred', linestyle='--', label=f'Mean: {df["Volatility"].mean():.2f}')
axes[3,0].set_title('30-Day Volatility Distribution', fontsize=15)
axes[3,0].set_xlabel('Standard Deviation')
axes[3,0].legend()

sns.lineplot(x=df['Date'], y=df['Volatility'], ax=axes[3,1], color='blue')
axes[3,1].set_title('Historical Volatility Trend', fontsize=15)
axes[3,1].set_xlabel('Date')
axes[3,1].set_ylabel('Volatility (30-day std dev)')

plt.tight_layout(rect=[0, 0, 1, 0.96])
plt.show()

# Numerical Summary Statistics
num_cols = ['Close', 'Returns', 'Volume', 'Volatility']
summary = df[num_cols].describe().T
summary['skewness'] = [df[c].skew() for c in num_cols]
summary['kurtosis'] = [df[c].kurtosis() for c in num_cols]

print("="*80)
print("COMPREHENSIVE NUMERICAL SUMMARY STATISTICS")
print(summary)

# Target Variable Analysis (Closing Price)
print("\n" + "="*80)
print("TARGET VARIABLE ANALYSIS (CLOSING PRICE)")
print(f"- Long-term trend: ${df['Close'].iloc[0]:.2f} â†’ ${df['Close'].iloc[-1]:.2f}")
print(f"- Maximum single-day gain: {df['Returns'].max():.2f}%")
print(f"- Maximum single-day loss: {df['Returns'].min():.2f}%")
print(f"- Days with >5% moves: {len(df[df['Returns'].abs() > 5])} ({len(df[df['Returns'].abs() > 5])/len(df)*100:.1f}% of days)")

# Price Movement Analysis
plt.figure(figsize=(10, 6))
direction = df['Returns'].apply(lambda x: 'Up' if x > 0 else 'Down' if x < 0 else 'Flat')
direction.value_counts().plot.pie(autopct='%1.1f%%', colors=['forestgreen', 'darkred', 'gray'])
plt.title('Daily Price Movement Direction')
plt.ylabel('')
plt.show()

"""# Bivariate Analysis"""

# 1. Correlation Analysis
plt.figure(figsize=(14, 12))
corr = df[['Close', 'Volume', 'Volatility', 'Returns']].corr()

# Pearson Correlation
plt.subplot(2, 2, 1)
sns.heatmap(corr, annot=True, cmap='coolwarm', fmt='.2f', vmin=-1, vmax=1)
plt.title('Pearson Correlation Matrix')

# Spearman Correlation
plt.subplot(2, 2, 2)
spearman_corr = df[['Close', 'Volume', 'Volatility', 'Returns']].corr(method='spearman')
sns.heatmap(spearman_corr, annot=True, cmap='viridis', fmt='.2f', vmin=-1, vmax=1)
plt.title('Spearman Rank Correlation Matrix')

plt.subplot(2, 2, 3)
scatter = sns.scatterplot(
    x=df['Close'],
    y=df['Volume'],
    alpha=0.6,
    hue=df['Returns'].abs(),
    palette='viridis',
    size=df['Volatility'],
    legend='full'  # Ensure legend shows both color and size info
)
plt.title('Price vs Volume (Colored by Absolute Return)')
plt.xlabel('Price (USD)')
plt.ylabel('Volume (Contracts)')
plt.yscale('log')


# Add label to the hue portion of the legend
scatter.legend_.texts[0].set_text('Absolute Return (%)')
plt.show()

# 3. Lagged Return Analysis
plt.subplot(2, 2, 4)
for lag in [1, 5, 20]:
    df[f'Return_lag_{lag}'] = df['Returns'].shift(lag)
    plt.scatter(df['Returns'], df[f'Return_lag_{lag}'], alpha=0.3, label=f'Lag {lag}')

plt.axhline(0, color='black', linestyle='--')
plt.axvline(0, color='black', linestyle='--')
plt.xlabel('Current Return')
plt.ylabel('Lagged Return')
plt.title('Current vs Lagged Returns')
plt.legend()
plt.grid(alpha=0.3)

plt.tight_layout()
plt.show()

import matplotlib.gridspec as gridspec

fig = plt.figure(figsize=(10, 6))
gs = gridspec.GridSpec(2, 2)  # Creates a 2x2 grid layout

ax2 = plt.subplot(gs[1])  # Targets the second cell (indexing starts at 0)

# Conditional Returns
ax2 = plt.subplot(gs[1])
high_vol = df[df['Volatility'] > df['Volatility'].quantile(0.75)]
low_vol = df[df['Volatility'] < df['Volatility'].quantile(0.25)]
sns.kdeplot(high_vol['Returns'], color='red', label='High Volatility')
sns.kdeplot(low_vol['Returns'], color='green', label='Low Volatility')
plt.title('Return Distribution by Volatility Regime')
plt.xlabel('Daily Return (%)')
plt.legend()

# Rolling Correlation: Price vs Volume
ax3 = plt.subplot(gs[2])
df['Rolling_Corr'] = df['Close'].rolling(window=90).corr(df['Volume'])
plt.plot(df['Date'], df['Rolling_Corr'], color='purple')
plt.axhline(0, color='black', linestyle='--')
plt.fill_between(df['Date'], df['Rolling_Corr'], 0, where=df['Rolling_Corr']>=0,
                 color='green', alpha=0.3, interpolate=True)
plt.fill_between(df['Date'], df['Rolling_Corr'], 0, where=df['Rolling_Corr']<0,
                 color='red', alpha=0.3, interpolate=True)
plt.title('90-Day Rolling Correlation: Price vs Volume')
plt.xlabel('Date')
plt.ylabel('Correlation Coefficient')

# Candlestick Chart for Key Period (2008 Financial Crisis)
ax4 = plt.subplot(gs[3])
crisis = df[(df['Date'] > '2008-08-01') & (df['Date'] < '2009-03-31')]
for i in range(len(crisis)):
    color = 'green' if crisis['Close'].iloc[i] >= crisis['Open'].iloc[i] else 'red'
    plt.plot([crisis['Date'].iloc[i], crisis['Date'].iloc[i]],
             [crisis['Low'].iloc[i], crisis['High'].iloc[i]],
             color=color, linewidth=1)
    plt.plot([crisis['Date'].iloc[i], crisis['Date'].iloc[i]],
             [crisis['Open'].iloc[i], crisis['Close'].iloc[i]],
             color=color, linewidth=3)

plt.title('Gold Prices During 2008 Financial Crisis')
plt.xlabel('Date')
plt.ylabel('Price (USD)')
plt.grid(alpha=0.3)

plt.tight_layout()
plt.show()

# 5. Directional Movement Analysis
plt.figure(figsize=(14, 6))

# Up/Down Days vs Volume
plt.subplot(1, 2, 1)
direction = np.sign(df['Returns']).map({1: 'Up', -1: 'Down', 0: 'Flat'})
sns.boxplot(x=direction, y=np.log(df['Volume']), palette=['red', 'green', 'gray'])
plt.title('Volume Distribution by Price Direction')
plt.xlabel('Price Movement')
plt.ylabel('Log Volume')

# Up/Down Days vs Volatility
plt.subplot(1, 2, 2)
sns.boxplot(x=direction, y=df['Volatility'], palette=['red', 'green', 'gray'])
plt.title('Volatility Distribution by Price Direction')
plt.xlabel('Price Movement')
plt.ylabel('30-Day Volatility')

plt.tight_layout()
plt.show()

# 6. Advanced Analysis: Lead-Lag Relationships
fig, ax = plt.subplots(3, 1, figsize=(14, 12))

# Cross-correlation analysis
max_lag = 10
correlations = [df['Returns'].corr(df['Returns'].shift(lag)) for lag in range(max_lag+1)]
ax[0].bar(range(max_lag+1), correlations, color='teal')
ax[0].set_title('Autocorrelation of Daily Returns')
ax[0].set_xlabel('Lag (Days)')
ax[0].set_ylabel('Correlation')
ax[0].set_xticks(range(max_lag+1))

# Volume-Volatility Relationship
sns.regplot(x=np.log(df['Volume']), y=df['Volatility'], ax=ax[1],
            scatter_kws={'alpha':0.3}, line_kws={'color':'red'})
ax[1].set_title('Volume vs Volatility Relationship')
ax[1].set_xlabel('Log Volume')
ax[1].set_ylabel('30-Day Volatility')

# Cumulative Returns by Volatility Regime
df['Cumulative_Return'] = (1 + df['Returns']/100).cumprod()
for regime, color in [('High', 'red'), ('Medium', 'gray'), ('Low', 'green')]:
    if regime == 'High':
        subset = df[df['Volatility'] > df['Volatility'].quantile(0.75)]
    elif regime == 'Low':
        subset = df[df['Volatility'] < df['Volatility'].quantile(0.25)]
    else:
        subset = df[(df['Volatility'] >= df['Volatility'].quantile(0.25)) &
                    (df['Volatility'] <= df['Volatility'].quantile(0.75))]
    ax[2].plot(subset['Date'], subset['Cumulative_Return'], color=color, label=f'{regime} Volatility')

ax[2].set_title('Cumulative Returns by Volatility Regime')
ax[2].set_xlabel('Date')
ax[2].set_ylabel('Cumulative Return')
ax[2].set_yscale('log')
ax[2].legend()

plt.tight_layout()
plt.show()

"""# Multivariate Analysis"""

from mpl_toolkits.mplot3d import Axes3D
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
from pandas.plotting import parallel_coordinates
import plotly.express as px

df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
# Create time-based features
df['Year'] = df['Date'].dt.year
df['Month'] = df['Date'].dt.month
df['Day'] = df['Date'].dt.day
df['Weekday'] = df['Date'].dt.weekday
df['Quarter'] = df['Date'].dt.quarter

# 1. 3D Visualization of Key Relationships
fig = plt.figure(figsize=(20, 15))

# Price-Volume-Returns
ax1 = fig.add_subplot(231, projection='3d')
scatter1 = ax1.scatter(df['Close'], np.log(df['Volume']), df['Returns'],
                      c=df['Volatility'], cmap='viridis', alpha=0.6)
ax1.set_xlabel('Price (USD)')
ax1.set_ylabel('Log Volume')
ax1.set_zlabel('Daily Return (%)')
ax1.set_title('Price-Volume-Return Relationship (Color: Volatility)')
fig.colorbar(scatter1, ax=ax1, label='Volatility')

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Create the figure and 3D subplot
fig = plt.figure(figsize=(12, 8))
ax2 = fig.add_subplot(111, projection='3d')  # or (232) if part of a larger grid

# Ensure Year is numeric
df['Year'] = df['Year'].astype(int)

# Plot each year's data
for year in sorted(df['Year'].unique()):
    year_data = df[df['Year'] == year]
    ax2.scatter(
        year_data['Year'],
        year_data['Volatility'],
        year_data['Returns'],
        alpha=0.5,
        label=str(year)
    )

# Set axis labels and title
ax2.set_xlabel('Year')
ax2.set_ylabel('Volatility')
ax2.set_zlabel('Daily Return (%)')
ax2.set_title('Temporal Evolution of Volatility-Return Relationship')

# Optional: limit legend to fewer entries
# handles, labels = ax2.get_legend_handles_labels()
# ax2.legend(handles[:5], labels[:5], loc='best')

# Show full legend or turn off if too crowded
ax2.legend(loc='upper left', bbox_to_anchor=(1.05, 1))

plt.tight_layout()
plt.show()

# 2. Pairplot with Market Regimes
df['Market_Regime'] = np.select(
    [
        df['Volatility'] < df['Volatility'].quantile(0.25),
        df['Volatility'] > df['Volatility'].quantile(0.75),
        df['Returns'] < df['Returns'].quantile(0.1),
        df['Returns'] > df['Returns'].quantile(0.9)
    ],
    ['Low Volatility', 'High Volatility', 'Crash Days', 'Surge Days'],
    default='Normal'
)

plt.figure(figsize=(12, 10))
sns.pairplot(df[['Close', 'Volume', 'Returns', 'Volatility', 'Market_Regime']],
             hue='Market_Regime', palette='viridis', corner=True, diag_kind='kde',
             plot_kws={'alpha': 0.5}, diag_kws={'alpha': 0.7})
plt.suptitle('Multivariate Relationships by Market Regime', y=1.02)
plt.show()

# 3. Principal Component Analysis (PCA)
features = ['Close', 'Volume', 'Returns', 'Volatility']
X = df[features].dropna()
X_scaled = StandardScaler().fit_transform(X)

pca = PCA(n_components=2)
principal_components = pca.fit_transform(X_scaled)
df_pca = pd.DataFrame(data=principal_components, columns=['PC1', 'PC2'])
df_pca['Market_Regime'] = df.loc[X.index, 'Market_Regime']

# PCA Visualization
plt.figure(figsize=(14, 10))
sns.scatterplot(x='PC1', y='PC2', hue='Market_Regime', data=df_pca,
                palette='Set1', alpha=0.7, s=80)
plt.title('PCA of Gold Market Features', fontsize=16)
plt.xlabel(f'PC1 ({pca.explained_variance_ratio_[0]*100:.1f}% Variance)')
plt.ylabel(f'PC2 ({pca.explained_variance_ratio_[1]*100:.1f}% Variance)')
plt.legend(title='Market Regime')
plt.grid(alpha=0.3)

# Add loadings
loadings = pca.components_.T * np.sqrt(pca.explained_variance_)
for i, feature in enumerate(features):
    plt.arrow(0, 0, loadings[i, 0], loadings[i, 1],
              color='black', alpha=0.7, head_width=0.1)
    plt.text(loadings[i, 0]*1.2, loadings[i, 1]*1.2,
             feature, color='black', ha='center', va='center')

plt.show()

# 4. Time-Evolving Relationships
# Rolling correlations
window_size = 90  # Quarterly window
df['Rolling_Corr_Price_Volume'] = df['Close'].rolling(window_size).corr(df['Volume'])
df['Rolling_Corr_Return_Volatility'] = df['Returns'].rolling(window_size).corr(df['Volatility'])

# Create 2x2 grid for time evolution plots
fig, axs = plt.subplots(2, 2, figsize=(18, 12), sharex=True)

# Plot 1: Rolling Correlations
axs[0, 0].plot(df['Date'], df['Rolling_Corr_Price_Volume'], 'b-', label='Price vs Volume')
axs[0, 0].plot(df['Date'], df['Rolling_Corr_Return_Volatility'], 'r-', label='Return vs Volatility')
axs[0, 0].axhline(0, color='black', linestyle='--', alpha=0.3)
axs[0, 0].set_title('Rolling 90-Day Correlations', fontsize=14)
axs[0, 0].set_ylabel('Correlation Coefficient')
axs[0, 0].legend()
axs[0, 0].grid(alpha=0.3)

# Plot 2: Volatility Clusters
for regime in ['High Volatility', 'Normal', 'Low Volatility']:
    subset = df[df['Market_Regime'] == regime]
    axs[0, 1].scatter(subset['Date'], subset['Volatility'],
                     label=regime, alpha=0.5, s=15)
axs[0, 1].set_title('Volatility Regimes Over Time', fontsize=14)
axs[0, 1].set_ylabel('Volatility')
axs[0, 1].legend()
axs[0, 1].grid(alpha=0.3)

# Plot 3: Volume Anomalies
axs[1, 0].bar(df['Date'], df['Volume'], color='purple', alpha=0.6)
axs[1, 0].set_title('Trading Volume with Market Regimes', fontsize=14)
axs[1, 0].set_ylabel('Volume (Contracts)')

# Add regime overlays
for regime, color in zip(['High Volatility', 'Crash Days', 'Surge Days'],
                         ['red', 'darkred', 'green']):
    regime_dates = df[df['Market_Regime'] == regime]['Date']
    for date in regime_dates:
        axs[1, 0].axvline(date, color=color, alpha=0.1)

# Plot 4: Cumulative Returns by Regime
for regime, color in zip(['Low Volatility', 'Normal', 'High Volatility'],
                         ['green', 'blue', 'red']):
    subset = df[df['Market_Regime'] == regime]
    cumulative_return = (1 + subset['Returns']/100).cumprod()
    axs[1, 1].plot(subset['Date'], cumulative_return,
                  color=color, label=regime)
axs[1, 1].set_title('Cumulative Returns by Market Regime', fontsize=14)
axs[1, 1].set_ylabel('Cumulative Return')
axs[1, 1].set_yscale('log')
axs[1, 1].legend()
axs[1, 1].grid(alpha=0.3)

plt.tight_layout()
plt.show()

# 5. Parallel Coordinates for Market Regimes
plt.figure(figsize=(14, 8))
parallel_cols = ['Close', 'Volume', 'Returns', 'Volatility', 'Market_Regime']
parallel_df = df[parallel_cols].copy()
parallel_df['Volume'] = np.log(parallel_df['Volume'])  # Normalize volume

# Sample to avoid overplotting
sampled_df = parallel_df.groupby('Market_Regime').apply(
    lambda x: x.sample(min(len(x), 100))).reset_index(drop=True)

parallel_coordinates(sampled_df, 'Market_Regime',
                     colormap='viridis', alpha=0.3)
plt.title('Multivariate Profile of Market Regimes', fontsize=16)
plt.ylabel('Standardized Value')
plt.xticks(rotation=20)
plt.grid(alpha=0.3)
plt.show()

